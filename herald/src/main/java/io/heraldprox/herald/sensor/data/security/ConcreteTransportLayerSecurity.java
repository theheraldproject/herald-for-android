//  Copyright 2021 Herald Project Contributors
//  SPDX-License-Identifier: Apache-2.0
//

package io.heraldprox.herald.sensor.data.security;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import io.heraldprox.herald.sensor.data.ConcreteSensorLogger;
import io.heraldprox.herald.sensor.data.SensorLogger;
import io.heraldprox.herald.sensor.datatype.Data;
import io.heraldprox.herald.sensor.datatype.Triple;
import io.heraldprox.herald.sensor.datatype.Tuple;
import io.heraldprox.herald.sensor.datatype.UInt32;

/**
 * Implementation of TLS based on Diffie-Hellman-Merkle key exchange and AES encryption.
 */
public class ConcreteTransportLayerSecurity implements TransportLayerSecurity {
    private final SensorLogger logger = new ConcreteSensorLogger("Sensor", "Data.Security.ConcreteTransportLayerSecurity");
    // Limitation : Public key is < 256 bytes
    private final Data.DataLengthEncodingOption encodingForPublicKeyCount = Data.DataLengthEncodingOption.UINT8;
    // Limitation : Encrypted data is < 65536 bytes
    private final Data.DataLengthEncodingOption encodingForEncryptedDataCount = Data.DataLengthEncodingOption.UINT16;
    @NonNull
    private final KeyExchange keyExchange;
    private final Integrity integrity = new SHA256();
    @NonNull
    private final Encryption encryption;
    private final Map<TransportLayerSecuritySessionID,TransportLayerSecuritySession> sessions = new ConcurrentHashMap<>();

    public ConcreteTransportLayerSecurity(@NonNull final DiffieHellmanParameters keyExchangeParameters, @NonNull final PseudoRandomFunction random) {
        this.keyExchange = new DiffieHellmanMerkle(keyExchangeParameters, random);
        this.encryption = new AES128(random);
    }

    public ConcreteTransportLayerSecurity(@NonNull final DiffieHellmanParameters keyExchangeParameters) {
        this(keyExchangeParameters, new SecureRandomFunction());
    }

    public ConcreteTransportLayerSecurity() {
        this(DiffieHellmanParameters.modpGroup14, new SecureRandomFunction());
    }

    /**
     * Alice reads public key from Bob. This function is called by Bob to create a new session for Alice and provide the public key.
     * @return Bob's public key.
     */
    @NonNull
    @Override
    public KeyExchangePublicKey readPublicKey() {
        final TransportLayerSecuritySession bobSession = new TransportLayerSecuritySession(keyExchange, integrity, encryption);
        sessions.put(bobSession.ownId, bobSession);
        return bobSession.ownPublicKey;
    }

    /**
     * Receive encoded data from peer.
     * <br>This function is called by Bob to establish a new session with Alice and decrypt the encrypted data from Alice.
     * <br>This function is also called by Alice to decrypt the optional encrypted data from Bob for an established session.
     * @param data Encoded data message generated by writeEncryptedData() or readEncryptedData()
     * @return Tuple of established session ID and decrypted data, or null on failure.
     */
    @Nullable
    @Override
    public Tuple<TransportLayerSecuritySessionID, Data> receiveEncryptedData(@NonNull final Data data) {
        final Triple<TransportLayerSecuritySessionID, Data, KeyExchangePublicKey> decodedData = decode(data);
        if (null == decodedData) {
            logger.fault("receiveEncryptedData failed, cannot decode message");
            return null;
        }
        final TransportLayerSecuritySessionID sessionId = decodedData.a;
        final Data encryptedData = decodedData.b;
        final KeyExchangePublicKey peerPublicKey = decodedData.c;
        final TransportLayerSecuritySession session = sessions.get(sessionId);
        if (null == session) {
            logger.fault("receiveEncryptedData failed, unknown session (sessionId={})", sessionId);
            return null;
        }
        // Establish session if public key has been provided and session is not already established
        if (null != peerPublicKey) {
            if (null == session.peerId && null == session.establishSession(peerPublicKey)) {
                logger.fault("receiveEncryptedData failed, cannot establish session (peerPublicKeyCount={})", peerPublicKey.value.length);
                return null;
            }
        }
        // Decrypt data using shared key
        final Data decryptedData = session.decrypt(encryptedData);
        if (null == decodedData) {
            logger.fault("receiveEncryptedData failed, cannot decrypt data");
            return null;
        }
        return new Tuple<>(sessionId, decryptedData);
    }

    /**
     * Alice receives public key from Bob. This function is called by Alice to establish a new session and pass encrypted data to Bob.
     * @param peerPublicKey Peer's public key.
     * @param data Data to be encrypted with derived shared key.
     * @return Encoded data comprising of (1) Bob's session ID, (2) data encrypted with shared key, (3) Alice's public key
     */
    @Nullable
    @Override
    public Data writeEncryptedData(@NonNull final KeyExchangePublicKey peerPublicKey, @NonNull final Data data) {
        final TransportLayerSecuritySession aliceSession = new TransportLayerSecuritySession(keyExchange, integrity, encryption);
        sessions.put(aliceSession.ownId, aliceSession);
        final TransportLayerSecuritySessionID bobSessionId = aliceSession.establishSession(peerPublicKey);
        if (null == bobSessionId) {
            logger.fault("writeEncryptedData failed, cannot establish session (peerPublicKeyCount={})", peerPublicKey.value.length);
            return null;
        }
        // Encrypt data using shared key
        final Data encryptedData = aliceSession.encrypt(data);
        if (null == encryptedData) {
            logger.fault("writeEncryptedData failed, cannot encrypt data");
            return null;
        }
        // Build encodedData = peerId + encryptedData + ownPublicKey
        final Data encodedData = encode(bobSessionId, encryptedData, aliceSession.ownPublicKey);
        if (null == encodedData) {
            logger.fault("writeEncryptedData failed, cannot encode message");
            return null;
        }
        return encodedData;
    }

    /**
     * Alice can optionally read encrypted data from Bob. This function is called by Bob to generate encrypted data for Alice using an established session.
     * @param sessionId Established session ID
     * @param data Data to be encrypted
     * @return Encoded data comprising of (1) Alice's session ID, (2) data encrypted with shared key
     */
    @Nullable
    @Override
    public Data readEncryptedData(@NonNull final TransportLayerSecuritySessionID sessionId, @NonNull final Data data) {
        final TransportLayerSecuritySession bobSession = sessions.get(sessionId);
        if (null == bobSession) {
            logger.fault("readEncryptedData failed, unknown session (sessionId={})", sessionId);
            return null;
        }
        // Encrypt data using shared key
        final Data encryptedData = bobSession.encrypt(data);
        if (null == encryptedData) {
            logger.fault("readEncryptedData failed, cannot encrypt data");
            return null;
        }
        // Build encodedData = peerId + encryptedData
        // (omitting public key as this is an established session)
        final TransportLayerSecuritySessionID aliceSessionId = bobSession.peerId;
        if (null == aliceSessionId) {
            // This should never happen as the ability to encrypt data implies the session is
            // established and therefore peer public key has been obtained and session ID derived
            logger.fault("readEncryptedData failed, missing peer session ID");
            return null;
        }
        final Data encodedData = encode(aliceSessionId, encryptedData, null);
        if (null == encodedData) {
            logger.fault("readEncryptedData failed, cannot encode message");
            return null;
        }
        return encodedData;
    }

    // MARK: - Encode/decode message

    @Nullable
    private Data encode(@NonNull final TransportLayerSecuritySessionID id, @NonNull final Data encrypted, @Nullable final KeyExchangePublicKey key) {
        final Data data = new Data();
        data.append(new UInt32(id.value));
        if (!data.append(encrypted, encodingForEncryptedDataCount)) {
            logger.fault("encode failed, encrypted data is too long (encryptedDataCount={})", encrypted.value.length);
            return null;
        }
        if (null == key) {
            return data;
        }
        if (!data.append(key, encodingForPublicKeyCount)) {
            logger.fault("encode failed, public key is too long (keyCount={})", key.value.length);
            return null;
        }
        return data;
    }

    @Nullable
    private Triple<TransportLayerSecuritySessionID,Data,KeyExchangePublicKey> decode(@NonNull final Data data) {
        final UInt32 idValue = data.uint32(0);
        if (null == idValue) {
            logger.fault("decode failed, cannot read id (dataCount={})", data.value.length);
            return null;
        }
        final Data.DecodedData encryptedData = data.data(4, encodingForEncryptedDataCount);
        if (null == encryptedData) {
            logger.fault("decode failed, cannot read encrypted data (dataCount={})", data.value.length);
            return null;
        }
        if (data.value.length == encryptedData.end) {
            return new Triple<>(new TransportLayerSecuritySessionID(idValue), encryptedData.value, null);
        }
        final Data.DecodedData keyData = data.data(encryptedData.end, encodingForPublicKeyCount);
        if (null == keyData) {
            logger.fault("decode failed, cannot read public key (dataCount={},encryptedEnd={})", data.value.length, encryptedData.end);
            return null;
        }
        return new Triple<>(new TransportLayerSecuritySessionID(idValue), encryptedData.value, new KeyExchangePublicKey(keyData.value));
    }
}
