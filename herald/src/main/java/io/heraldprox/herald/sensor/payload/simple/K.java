//  Copyright 2020-2021 Herald Project Contributors
//  SPDX-License-Identifier: Apache-2.0
//

package io.heraldprox.herald.sensor.payload.simple;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import io.heraldprox.herald.sensor.data.ConcreteSensorLogger;
import io.heraldprox.herald.sensor.data.SensorLogger;
import io.heraldprox.herald.sensor.datatype.TimeInterval;

import java.security.SecureRandom;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;

/**
 * Key generation functions for the Simple Payload.
 */
@SuppressWarnings("ConstantConditions")
public class K {
    // Secret key length
    private final static int secretKeyLength = 2048;
    // Days supported by key derivation function
    private final static int days = 2000;
    // Periods per day
    private final static int periods = 240;
    // Epoch as time interval since 1970
    private final static TimeInterval epoch = K.getEpoch();

    /**
     * Date from string date "yyyy-MM-dd'T'HH:mm:ssXXXX" in UTC
     * 
     * @param fromString Time string in UTC timezone
     * @return Herald Date instance
     */
    @Nullable
    protected static Date date(@NonNull final String fromString) {
        final SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", Locale.UK);
        // Only ever used in tests. K class only uses UTC.
        format.setTimeZone(TimeZone.getTimeZone("UTC"));
        try {
            return format.parse(fromString);
        } catch (Throwable e) {
            return null;
        }
    }

    /**
     * Epoch for calculating days and periods
     * @return
     */
    @NonNull
    protected static TimeInterval getEpoch() {
        final Date date = date("2020-09-24T00:00:00+0000");
        //noinspection ConstantConditions
        return new TimeInterval(date.getTime() / 1000);
    }

    /**
     * Epoch day for selecting matching key
     * @param onDate
     * @return
     */
    protected static int day(@NonNull final Date onDate) {
        return (int) ((new TimeInterval(onDate).value - epoch.value) / 86400);
    }

    /**
     * Epoch day period for selecting contact key
     * @param atTime
     * @return
     */
    protected static int period(@NonNull final Date atTime) {
        final int second = (int) ((new TimeInterval(atTime).value - epoch.value) % 86400);
        return second / (86400 / periods);
    }

    /**
     * Generate 2048-bit secret key, K_s
     * @return
     */
    @NonNull
    protected static SecretKey secretKey() {
        final SecureRandom secureRandom = getSecureRandom();
        final byte[] bytes = new byte[secretKeyLength];
        secureRandom.nextBytes(bytes);
        return new SecretKey(bytes);
    }

    @NonNull
    public static SecureRandom getSecureRandom() {
        // TODO : Switch to NonBlockingSecureRandom
        final SensorLogger logger = new ConcreteSensorLogger("Sensor", "Payload.Simple.K");
        try {
            // Retrieve a SHA1PRNG
            final SecureRandom sr = SecureRandom.getInstance("SHA1PRNG");
            // Generate a secure seed
            final SecureRandom seedSr = new SecureRandom();
            // We need a 440 bit seed - see NIST SP800-90A
            final byte[] seed = seedSr.generateSeed(55);
            sr.setSeed(seed); // seed with random number
            // Securely generate bytes
            sr.nextBytes(new byte[256 + sr.nextInt(1024)]); // start from random position
            return sr;
        } catch (Throwable e) {
            logger.fault("Could not retrieve SHA1PRNG SecureRandom instance", e);
            return new SecureRandom();
        }
    }

    /**
     * Forward secured matching key seeds are generated by a reversed hash chain with truncation, to ensure future keys cannot be derived from historic keys.
     * The cryptographic hash function offers a one-way function for forward security. The truncation function offers additional assurance by deleting intermediate
     * key material, thus a compromised hash function will still maintain forward security.
     *
     * @param secretKey Secret key.
     * @param onDay Required day from epoch.
     * @return Matching key seed for required day derived from secret key.
     */
    @Nullable
    protected static MatchingKeySeed matchingKeySeed(@NonNull final SecretKey secretKey, final int onDay) {
        // The last matching key seed on day 2000 (over 5 years from epoch) is the
        // hash of the secret key. A new secret key will need to be established
        // before all matching key seeds are exhausted on day 2000.
        if (!(onDay <= K.days && onDay >= 0)) {
            return null;
        }
        MatchingKeySeed matchingKeySeed = new MatchingKeySeed(F.hash(secretKey));
        int matchingKeySeedDay = K.days;
        // Work backwards from day 2000 to derive seeds for day 1999, 1998, until
        // reaching the required day
        while (matchingKeySeedDay > onDay) {
            matchingKeySeed = new MatchingKeySeed(F.hash(F.truncate(matchingKeySeed)));
            matchingKeySeedDay -= 1;
        }
        return matchingKeySeed;
    }

    /**
     * Matching key for day i is the hash of the matching key seed for day i xor i - 1. A separation of matching key from its seed is necessary because the
     * matching key is distributed by the server to all phones for on-device matching in a decentralised contact tracing solution. Given a seed is used to
     * derive the seeds for other days, publishing the hash prevents an attacker from establishing the other seeds.
     *
     * @param deriveFrom Matching key seed.
     * @return Matching key derived from matching key seed.
     */
    @NonNull
    protected static MatchingKey matchingKey(@NonNull final MatchingKeySeed deriveFrom) {
        // Matching key on day N is derived from matching key seed on day N and day N-1
        final MatchingKeySeed matchingKeySeedMinusOne = new MatchingKeySeed(F.hash(F.truncate(deriveFrom)));
        final MatchingKey matchingKey = new MatchingKey(F.hash(F.xor(deriveFrom, matchingKeySeedMinusOne)));
        return matchingKey;
    }

    /**
     * Forward secured contact key seeds are generated by a reversed hash chain with truncation, to ensure future keys cannot be derived from historic
     * keys. This is identical to the procedure for generating the matching key seeds. The seeds are never transmitted from the phone. They are
     * cryptographically challenging to reveal from the broadcasted contact keys, while easy to generate given the matching key, or secret key.
     *
     * @param deriveFrom Matching key.
     * @param forPeriod Required period of the day.
     * @return Contact key seed derived from matching key for the required period.
     */
    @Nullable
    protected static ContactKeySeed contactKeySeed(@NonNull final MatchingKey deriveFrom, final int forPeriod) {
        // The last contact key seed on any day at period 240 (last 6 minutes of the day)
        // is the hash of the matching key for the day.
        if (!(forPeriod <= K.periods && forPeriod >= 0)) {
            return null;
        }
        ContactKeySeed contactKeySeed = new ContactKeySeed(F.hash(deriveFrom));
        int contactKeySeedPeriod = K.periods;
        // Work backwards from period 240 to derive seeds for period 239, 238, until
        // reaching the required period
        while (contactKeySeedPeriod > forPeriod) {
            contactKeySeed = new ContactKeySeed(F.hash(F.truncate(contactKeySeed)));
            contactKeySeedPeriod -= 1;
        }
        return contactKeySeed;
    }

    /**
     * Consumer for the forEachContactIdentifier function.
     */
    public interface ForEachContactIdentifierAction {
        void consume(@NonNull final ContactIdentifier contactIdentifier, final int period);
    }

    public static void forEachContactIdentifier(@NonNull final MatchingKey deriveFrom, @NonNull final ForEachContactIdentifierAction action) {
        ContactKeySeed contactKeySeed = new ContactKeySeed(F.hash(deriveFrom));
        int contactKeySeedPeriod = K.periods;
        action.consume(contactIdentifier(contactKey(contactKeySeed)), contactKeySeedPeriod);
        // Work backwards from period 240 to derive seeds for period 239, 238, until
        // reaching the required period
        while (contactKeySeedPeriod >= 0) {
            contactKeySeed = new ContactKeySeed(F.hash(F.truncate(contactKeySeed)));
            contactKeySeedPeriod -= 1;
            action.consume(contactIdentifier(contactKey(contactKeySeed)), contactKeySeedPeriod);
        }
    }

    public static ContactKey contactKey(@NonNull final ContactKeySeed deriveFrom) {
        // Contact key at period N is derived from contact key seed at period N and period N-1
        final ContactKeySeed contactKeySeedMinusOne = new ContactKeySeed(F.hash(F.truncate(deriveFrom)));
        final ContactKey contactKey = new ContactKey(F.hash(F.xor(deriveFrom, contactKeySeedMinusOne)));
        return contactKey;
    }

    /**
     * Generate contact identifer I_{c}
     *
     * @param contactKey The ContactKey used to generate this period's ContactIdentifier
     */
    @NonNull
    protected static ContactIdentifier contactIdentifier(@NonNull final ContactKey contactKey) {
        return new ContactIdentifier(F.truncate(contactKey, 16));
    }
}
